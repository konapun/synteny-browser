var SyntenyBrowser = function(div, opts) {
	/* Set up scaffolding */
	var
	topBrowsers = document.createElement('div'),
	bottomBrowsers = document.createElement('div'),
	syntenyArea = document.createElement('div'),
	syntenyCanvas = document.createElement('canvas');
	
	syntenyArea.appendChild(syntenyCanvas);
	div.appendChild(topBrowsers);
	div.appendChild(syntenyArea);
	div.appendChild(bottomBrowsers);
	
	this.syntenyBrowser = div;
	this.topArea = topBrowsers;
	this.syntenyCanvas = syntenyCanvas;
	this.bottomArea = bottomBrowsers;
	this.browsers = [];
	this.width = 1000;
};

SyntenyBrowser.prototype = function() {
	var
	addSequence = function(sequence, start) {
		var scriblCanvas = document.createElement('canvas');
		scriblCanvas.width = this.width;
		
		var browser = new SyntenyBrowser.Browser(this, scriblCanvas);
		browser.scribl.addGene(start, start + sequence.length, '+'); //FIXME: not a gene (use sequence glyph instead)
		
		this.browsers.push(browser);
		return browser;
	},
	width = function(width) {
		if (typeof width !== 'undefined') {
			this.width = width;
		}
		
		return this.width;
	},
	draw = function() {
		var loadTop = true;
		for (var i = 0, length = this.browsers.length; i < length; i++) {
			var
			loadArea = loadTop ? this.topArea : this.bottomArea,
			browser = this.browsers[i],
			canvas = browser.scribl.canvas;
			
			loadArea.appendChild(canvas);
			browser.scribl.draw();
			loadTop = !loadTop;
		}
		
		mergeCanvases(this);
	},
	
	/* Private functions */
	mergeCanvases = function(caller) {
		var
		projectionCanvas = caller.syntenyCanvas,
		merged = document.createElement('canvas'),
		ctx = merged.getContext('2d');
		
		var height = projectionCanvas.height;
		for (var i = 0, len = caller.browsers.length; i < len; i++) {
			height += caller.browsers[i].height;
		}
		
		merged.height = height;
		merged.width = caller.browsers[0].width;
		
		var y = 0;
		for (var i = 0, len = topArea.length; i < len; i++) {
			var canvas = topArea[i].canvas;
			
			ctx.drawImage(canvas, 0, y);			
			y += canvas.height;
		}
		ctx.drawImage(projectionCanvas, 0, y);
		y += projectionCanvas.height;
		for (var i = 0, len = bottomArea.length; i < len; i++) {
			var canvas = bottomArea[i].canvas;
			
			ctx.drawImage(canvas, 0, y);
			y += canvas.height;
		}
	};
	
	return {
		addSequence: addSequence,
		width: width,
		draw: draw
	};
}();

SyntenyBrowser.Browser = function(browser, canvas) {
	this.scribl = new Scribl(canvas, canvas.width);
	this.browser = browser;
};

SyntenyBrowser.Browser.prototype = function() {
	var
	selectRegion = function(start, end) {
		var
		scribl = this.scribl,
		scriblCanvas = scribl.canvas,
		ctx = scriblCanvas.getContext('2d'),
		scaleStart = scribl.scale.min,
		scaleEnd = scribl.scale.max,
		region = new SyntenyBrowser.Region(this, this.browser.syntenyCanvas, start, end),
		pxPerNucs = scribl.pixelsToNts(),
		padding = 15,
		drawStartX = padding + (start * pxPerNucs),
		drawStartY = 10,
		drawEndX = padding + (end * pxPerNucs),
		drawEndY = 30;
		
		ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
		ctx.fillRect(drawStartX, drawStartY, drawEndX - drawStartX, drawEndY - drawStartY);
		
		region.drawStartX = drawStartX;
		region.drawEndX = drawEndX;
		region.drawStartY = drawStartY;
		region.drawEndY = drawEndY;
		
		return region;
	};
	
	return {
		selectRegion: selectRegion
	};
}();

SyntenyBrowser.Region = function(regionOwner, projectionCanvas, start, end) {
	this.owner = regionOwner;
	this.projectionCanvas = projectionCanvas;
	this.start = start;
	this.end = end;
};

SyntenyBrowser.Region.prototype = function() {
	var
	compareWith = function(region) {
		var alignService = 'align_sequence.php'; // Ideally, this would be a webservice
		
		//TODO
		var
		seq1 = 'ACTGACGATCTG',
		seq2 = 'ACTGACGATCTG',
		alignment = new SyntenyBrowser.Alignment(this.projectionCanvas, seq1, seq2);
		
		alignment.draw();
		//canvasMerge(this); //FIXME: call from syntenybrowser
		projectToAlignment(this, alignment);
		projectToAlignment(region, alignment);
	},
	
	/* private functions */
	projectToAlignment = function(caller, alignment) {
		var
		ctx = caller.projectionCanvas.getContext('2d'),
		regionX1 = caller.drawStartX,
		regionY1 = caller.drawStartY,
		regionX2 = caller.drawEndX,
		regionY2 = caller.drawEndY,
		alignmentX1 = alignment.drawStartX,
		alignmentY1 = alignment.drawStartY,
		alignmentX2 = alignment.drawEndX,
		alignmentY2 = alignment.drawEndY;
		
		ctx.fillStyle = 'rgba(255, 100, 100, 0.5)';
		ctx.beginPath();
		ctx.moveTo(regionX1, regionY1);
		ctx.lineTo(alignmentX1, alignmentY1);
		ctx.lineTo(alignmentX2, alignmentY1);
		ctx.lineTo(regionX2, regionY1);
		ctx.lineTo(regionX1, regionY1);
		ctx.fill();
		if (regionY2 < alignmentY1) { // project from bottom
			
		}
		else { // project from top
			
		}
	};
	
	return {
		compareWith: compareWith
	};
}();

/* Internal Objects */
SyntenyBrowser.Alignment = function(canvas, seq1, seq2) {
	var
	scribl = new Scribl(canvas, canvas.width),
	padder = document.createElement('span'),
	glyph1 = scribl.addFeature(new Seq('sequence1', 1, seq1.length, seq1)),
	glyph2 = scribl.addFeature(new Seq('sequence2', 1, seq2.length, seq2));
	
	$(padder).css('background-color', 'red').css('width', '500px');
	$(canvas).insertBefore(padder);
	
	this.canvas = canvas;
	this.padder = padder;
	this.scribl = scribl;
	this.seq1 = seq1;
	this.seq2 = seq2;
	this.pxPerNuc = 10;
};

SyntenyBrowser.Alignment.prototype = function() {
	var
	draw = function() {
		var
		
		scribl = this.scribl,
		seqlen = this.seq1.length > this.seq2.length ? this.seq1.length : this.seq2.length;
		proposedWidth = this.pxPerNuc * seqlen;
		if (proposedWidth < this.canvas.width) {
			//this.canvas.width = proposedWidth; //FIXME
			//TODO
		}
		
		this.canvas.width = 500;
		
		this.drawStartX = 20;
		this.drawEndX = 500;
		this.drawStartY = 0;
		this.drawEndY = 100;
		
		scribl.scale.off = true;
		return scribl.draw();
	};
	
	return {
		draw: draw
	};
}();